<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Yangyuanchen Liu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Yangyuanchen Liu</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./publications.html" aria-current="page"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./posts.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/yangyuanchen-liu-239148120/" target="_blank"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:yliu664@jh.edu"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/lyyc199586/" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#papers" id="toc-papers" class="nav-link active" data-scroll-target="#papers">Papers</a></li>
  <li><a href="#presentations" id="toc-presentations" class="nav-link" data-scroll-target="#presentations">Presentations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">




<section id="papers" class="level2">
<h2 class="anchored" data-anchor-id="papers">Papers</h2>
<p><strong>The strength of the Brazilian fracture test</strong> (2024). <em>A. Kumar, <strong>Y. Liu</strong>, J. E. Dolbow, O. Lopez-Pamies</em>. <em>Journal of the Mechanics and Physics of Solids</em> 182, 105473. <a href="https://doi.org/10.1016/j.jmps.2023.105473"><img src="https://img.shields.io/badge/DOI-10.1016/j.jmps.2023.105473-blue.svg" class="img-fluid" alt="DOI: 10.1016/j.jmps.2023.105473"></a></p>
<details>
<summary>
Abstract
</summary>
Since its introduction in the 1940s until present times, the so-called Brazilian test has been embraced by practitioners worldwide as a method of choice to indirectly measure the tensile strength of concrete, rocks, and other materials with a large compressive strength relative to their tensile strength. This is because of the ease that the test affords in both the preparation of the specimen (a circular disk) and the application of the loads (two platens compressing the specimen between them). Yet, this practical advantage has to be tempered by the fact that the observations from a Brazilian test — being an indirect experiment in the sense that it involves not uniform uniaxial tension but non-uniform triaxial stress states throughout the specimen —have to be appropriately interpreted to be useful. The main objective of this paper is to carry out a complete quantitative analysis of where and when fracture nucleates and propagates in a Brazilian test and thereby establish how to appropriately interpret its results. We do so by deploying the phase-field fracture theory of Kumar et al.&nbsp;(2020), which has been recently established as a complete theory of fracture capable of accurately describing the nucleation and propagation of cracks in linear elastic brittle materials under arbitrary quasistatic loading conditions. The last section of this paper puts forth a new protocol to deduce the tensile strength of a material from a Brazilian test that improves on the current ISRM and ASTM standards.
</details>
<p><strong>A model-based simulation framework for coupled acoustics, elastodynamics, and damage with application to nano-pulse lithotripsy</strong> (2024). <em><strong>Y. Liu</strong>, P. Zhong, O. Lopez-Pamies, J. E. Dolbow</em>. <em>International Journal of Solids and Structures</em> 289, 112626. <a href="https://doi.org/10.1016/j.ijsolstr.2023.112626"><img src="https://img.shields.io/badge/DOI-10.1016/j.ijsolstr.2023.112626-blue.svg" class="img-fluid" alt="DOI: 10.1016/j.ijsolstr.2023.112626"></a></p>
<details>
<summary>
Abstract
</summary>
We develop a model for solid objects surrounded by a fluid that accounts for the possibility of acoustic pressures giving rise to damage on the surface of the solid. The propagation of an acoustic pressure in the fluid domain is modeled by the acoustic wave equation. On the other hand, the response of the solid is described by linear elastodynamics coupled with a gradient damage model, one that is based on a cohesive-type phasefield description of fracture. The interaction between the acoustic pressure and the deformation and damage of the solid are represented by transmission conditions at the fluid–solid interface. The resulting governing equations are discretized using a finite-element/finite-difference method that pays particular attention to the spatial and temporal scales that need to be resolved. Results from model-based simulations are provided for a benchmark problem as well as for recent experiments in nano-pulse lithotripsy. A parametric study is performed to illustrate how damage develops in response to the driving force (magnitude and location of the acoustic source) as a function of the fracture resistance of the solid. The results are shown to be qualitatively consistent with experimental observations for the location and size of the damage fields on the solid surface. A study of limiting cases also suggests that both the threshold for damage and the critical fracture energy are important to consider in order to capture the transition from damage initiation to complete localization. A low-cycle fatigue model is proposed that degrades the fracture resistance of the solid as a function of accumulated tensile strain energy, and it is shown to be capable of capturing damage localization in simulations of multi-pulse nano-pulse lithotripsy.
</details>
<p><strong>A computational framework for simulating crack nucleation and growth in materials subjected to dynamic loads</strong> (2024). <strong><em>Y. Liu</em></strong>. <em>Duke University</em> , 153.</p>
<details>
<summary>
Abstract
</summary>
Understanding dynamic fracture is essential for predicting the structural integrity and lifespan of engineering components, especially in critical fields like aerospace, civil engineering, and materials manufacturing. Dynamic fracture involves crack propagation under rapid loading conditions, where the loading rate impacts the fracture process. Dynamic fracture is particularly important in scenarios such as impact, fragmentation, and high-speed machining, where materials are subjected to sudden and extreme forces. Both crack nucleation and propagation are crucial in dynamic fracture. The precise conditions under which cracks nucleate is the key to predict failure onset and implementing preventive measures. Once a crack has nucleated, its propagation under dynamic loading is also challenging due to complex stress wave interactions and inertial effects that influence the crack path and speed. Traditional fracture analysis methods often struggle to accurately predict crack behavior under these dynamic conditions.The research presented in this dissertation aims to address the aforementioned challenges. A unified computational framework is developed to simulate both crack nucleation and growth under dynamic loads. In essence, a phase-field model designed for fracture under quasi-static loading conditions is extended to account for dynamic fracture. The framework accounts for an arbitrary material strength surface through an external driving force in the evolution equation for the phase field. The framework is appealing because it models arbitrary material strength without compromising Griffith’s criterion. The developed computational framework has been validated against a broad range of experimental observations, demonstrating the importance of accurately representing material strength. A complete analysis of fracture nucleation and propagation during the Brazilian test is presented; the framework also simulates coupled acoustics, elastodynamics, and damage with application to nano-pulse lithotripsy; and the framework has been validated against the impact experiments by Kalthoff and Winkler, a dynamic version of the Brazilian fracture test, and a recent experiment investigating crack initiation, propagation, and branching in soda-lime glass specimens.
</details>
<p><strong>On the effects of material strength in dynamic fracture: A phase-field study</strong> (2024). <em><strong>Y. Liu</strong>, O. Lopez-Pamies, J. E. Dolbow</em>. <em>arXiv preprint</em> , . <a href="https://doi.org/10.48550/arXiv.2411.16393"><img src="https://img.shields.io/badge/DOI-10.48550/arXiv.2411.16393-blue.svg" class="img-fluid" alt="DOI: 10.48550/arXiv.2411.16393"></a></p>
<details>
<summary>
Abstract
</summary>
<p>Over the past seven years, full-field analyses of a wide range of classical as well as modern quasi-static fracture experiments on nominally elastic brittle materials – ranging from hard ceramics to soft elastomers – have repeatedly identified the material strength surface as one of the key material properties that governs not only the nucleation of cracks, but also their propagation. Central to these analyses are the results generated by the Griffith phase-field fracture theory with material strength introduced in [21,23,20]. The first of two objectives of this paper is to extend this theory to account for inertia, this for the basic case of isotropic linear elastic brittle materials. From an applications point of view, the theory amounts to solving an initial-boundary-value problem comprised of a hyperbolic PDE coupled with an elliptic PDE for the displacement field <span class="math inline">\(u(X,t)\)</span> and the phase field <span class="math inline">\(d(X,t)\)</span>. A robust scheme is presented to generate solutions for these equations that is based on an adaptive finite-element discretization of space and an implicit finite-difference discretization of time. At every time increment tm, the resulting discretized equations are solved separately in a staggered manner for <span class="math inline">\(u(X,t_m)\)</span> and <span class="math inline">\(d(X,t_m)\)</span> by means of Newton-Raphson schemes. The second objective is to illustrate the descriptive and predictive capabilities of the proposed theory via simulations of benchmark problems and experiments. These include problems involving fracture nucleation from large pre-existing cracks, such as the classical Kalthoff-Winkler experiments, as well as problems involving fracture nucleation within the bulk, such as the dynamic Brazilian fracture experiments.</p>
</details>
<p><strong>Model-based simulations of pulsed laser ablation using an embedded finite element method</strong> (2023). <em><strong>Y. Liu</strong>, S. Claus, P. Kerfriden, J. Chen, P. Zhong, J. E. Dolbow</em>. <em>International Journal of Heat and Mass Transfer</em> 204, 123843. <a href="https://doi.org/10.1016/j.ijheatmasstransfer.2022.123843"><img src="https://img.shields.io/badge/DOI-10.1016/j.ijheatmasstransfer.2022.123843-blue.svg" class="img-fluid" alt="DOI: 10.1016/j.ijheatmasstransfer.2022.123843"></a></p>
<details>
<summary>
Abstract
</summary>
A model of thermal ablation with application to multi-pulsed laser lithotripsy is presented. The approach is based on a one-sided Stefan-Signorini model for thermal ablation, and relies on a level-set function to represent the moving interface between the solid phase and a fictitious gas phase (representing the ablated material). The model is discretized with an embedded finite element method, wherein the interface geometry can be arbitrarily located relative to the background mesh. Nitsche’s method is adopted to impose the Signorini condition on the moving interface. A bound constraint is also imposed to deal with thermal shocks that can arise during representative simulations of pulsed ablation with high-power lasers. We report simulation results based on experiments for pulsed laser ablation of wet BegoStone samples treated in air, where Begostone has been used as a phantom material for kidney stone. The model is calibrated against experimental measurements by adjusting the percentage of incoming laser energy absorbed at the surface of the stone sample. Simulation results are then validated against experimental observations for the crater area, volume, and geometry as a function of laser pulse energy and duration. Our studies illustrate how the spreading of the laser beam from the laser fiber tip with concomitantly reduced incident laser irradiance on the damaged crater surface explains trends in both the experimental observations and the model-based simulation results.
</details>
<p><strong>Shock waves generated by toroidal bubble collapse are imperative for kidney stone dusting during Holmium:YAG laser lithotripsy</strong> (2023). <em>G. Xiang, J. Chen, D. Ho, G. Sankin, X. Zhao, <strong>Y. Liu</strong>, K. Wang, J. Dolbow, J. Yao, P. Zhong</em>. <em>Ultrasonics Sonochemistry</em> 101, 106649. <a href="https://doi.org/10.1016/j.ultsonch.2023.106649"><img src="https://img.shields.io/badge/DOI-10.1016/j.ultsonch.2023.106649-blue.svg" class="img-fluid" alt="DOI: 10.1016/j.ultsonch.2023.106649"></a></p>
<details>
<summary>
Abstract
</summary>
Holmium:yttrium-aluminum-garnet (Ho:YAG) laser lithotripsy (LL) has been the treatment of choice for kidney stone disease for more than two decades, yet the mechanisms of action are not completely clear. Besides photothermal ablation, recent evidence suggests that cavitation bubble collapse is pivotal in kidney stone dusting when the Ho:YAG laser operates at low pulse energy (Ep) and high frequency (F). In this work, we perform a comprehensive series of experiments and modelbased simulations to dissect the complex physical processes in LL. Under clinically relevant dusting settings (Ep = 0.2 J, F = 20 Hz), our results suggest that majority of the irradiated laser energy ({}90 %) is dissipated by heat generation in the fluid surrounding the fiber tip and the irradiated stone surface, while only about 1 % may be consumed for photothermal ablation, and less than 0.7 % is converted into the potential energy at the maximum bubble expansion. We reveal that photothermal ablation is confined locally to the laser irradiation spot, whereas cavitation erosion is most pronounced at a fiber tip-stone surface distance about 0.5 mm where multi foci ring-like damage outside the thermal ablation zone is observed. The cavitation erosion is caused by the progressively intensified collapse of jetinduced toroidal bubble near the stone surface ({}100 μm), as a result of Raleigh-Taylor and Richtmyer-Meshkov instabilities. The ensuing shock wave-stone interaction and resultant leaky Rayleigh waves on the stone surface may lead to dynamic fatigue and superficial material removal under repeated bombardments of toroidal bubble collapses during dusting procedures in LL.
</details>
<p><strong>Multiresponse shape-memory nanocomposite with a reversible cycle for powerful artificial muscles</strong> (2021). <em>C. Chen, <strong>Y. Liu</strong>, X. He, H. Li, Y. Chen, Y. Wei, Y. Zhao, Y. Ma, Z. Chen, X. Zheng, H. Liu</em>. <em>Chem. Mater.</em> 33, 987–997. <a href="https://doi.org/10.1021/acs.chemmater.0c04170"><img src="https://img.shields.io/badge/DOI-10.1021/acs.chemmater.0c04170-blue.svg" class="img-fluid" alt="DOI: 10.1021/acs.chemmater.0c04170"></a></p>
<details>
<summary>
Abstract
</summary>
In the ﬁeld of bionic soft robots and microrobots, artiﬁcial muscle materials have exhibited unique potential for cutting-edge applications. However, current mainstream thermal-responsive artiﬁcial muscles based on semicrystalline polymers (SCPs), despite their excellent physical properties, suﬀer from the limitation of environmental stimuli in practice, while their photodriven counterparts adopting liquid crystal elastomers (LCEs) lack ductility. Herein, a novel multifunctional programmable artiﬁcial muscle with a unique patch-sewing structure formed by π−π stacking between azobenzene groups was designed, which combined the advantages of SCPs and LCEs. The nanocomposite demonstrated a unique combination between artiﬁcial muscle performance (46.5 times the energy density and 26.6 times the power density of human skeletal muscles) and programmability (274.84% strain and 100% shape-memory recovery rate within 1 s). Meanwhile, coupling the photoisomerization of azobenzene and the photothermal conversion of gold nanorods, the cycle of deformation triggered by ultraviolet light and restoring by infrared light could be accomplished rapidly within 30 s. A COMSOL Multiphysics model was established and the corresponding ﬁnite element analysis veriﬁed the photoactuation and captured the general principle of light initiation in elastomers. These demonstrate that the multifunctional programmable elastomer is promising for artiﬁcial muscle applications, especially for photoinduced actuation.
</details>
<p><strong>A micromechanics-informed phase field model for brittle fracture accounting for unilateral constraint</strong> (2020). <em><strong>Y. Liu</strong>, C. Cheng, V. Ziaei-Rad, Y. Shen</em>. <em>Engineering Fracture Mechanics</em> , 107358. <a href="https://doi.org/10.1016/j.engfracmech.2020.107358"><img src="https://img.shields.io/badge/DOI-10.1016/j.engfracmech.2020.107358-blue.svg" class="img-fluid" alt="DOI: 10.1016/j.engfracmech.2020.107358"></a></p>
<details>
<summary>
Abstract
</summary>
We propose a new direction-dependent model for the unilateral constraint involved in the phase field approach to fracture and also in the continuous damage mechanics models. The construction of this phase field model is informed by micromechanical modeling through the homogenization theory, where the representative volume element (RVE) has a planar crack in the center. The proposed model is made closely match the response of the RVE, including the frictionless self-contact condition. This homogenization approach allows to identify a direction-dependent phase field model with the tension-compression split obtained from cracked microstructures. One important feature of the proposed model is that unlike most other models, the material degradation is consistently determined without artificial assumptions or ad hoc parameters with no physical interpretation, thus, a more realistic modeling is resulted. With standard tests such as uniaxial loadings, three-point bending, simple shear, and through-crack tests, the proposed model predicts reasonable crack paths. Moreover, with the RVE response as a benchmark, the proposed model gives rise to an accurate stress-strain curve under shear loads, more accurate than most existing models.
</details>
<p><strong>A manifold learning approach to accelerate phase field fracture simulations in the representative volume element</strong> (2020). <em><strong>Y. Liu</strong>, K. Weng, Y. Shen</em>. <em>SN Applied Sciences</em> 2, 1682.</p>
<details>
<summary>
Abstract
</summary>
The multiscale simulation of heterogeneous materials is a popular and important subject in solid mechanics and materials science due to the wide application of composite materials. However, the classical FE<span class="math inline">\(^2\)</span> (finite element<span class="math inline">\(^2\)</span>) scheme can be costly, especially when the microproblem is nonlinear. In this paper, we consider the case when the microproblem is the phase field formulation for fracture. We adopt the locally linear embedding (LLE) manifold learning approach, a method for non-linear dimension reduction, to extract the manifold that contains a collection of phase-field-represented initial microcrack patterns in the representative volume element (RVE). Then the output data corresponding to any other microcrack pattern, e.g., the evolved phase field at a fixed load, can be accurately reconstructed using the learned manifold with minimum computation. The method has two features: a minimum number of parameters for the scheme, and an input-specific error bar. The latter feature enables an adaptive strategy for any new input on whether to use the proposed, less expensive reconstruction, or to use an accurate but costly high-fidelity computation instead.
</details>
</section>
<section id="presentations" class="level2">
<h2 class="anchored" data-anchor-id="presentations">Presentations</h2>
<p><strong>A model-based simulation framework for coupled acoustics, elastodynamics, and damage with application to nano-pulse lithotripsy</strong> (2023). <em><strong>Y. Liu</strong>, P. Zhong, O. Lopez-Pamies, J. E. Dolbow</em>. Presented at <em>the 17th United States National Congress on Computational Mechanics (USNCCM17)</em>, Albuquerque, New Mexico</p>
<p><strong>Model-based simulations of pulsed laser ablation using a CutFEM method</strong> (2022). <em><strong>Y. Liu</strong>, S. Claus, P. Kerfriden, J. Chen, P. Zhong, J. E. Dolbow</em>. Presented at <em>The 15th World Congress on Computational Mechanics (WCCM15)</em>, Yokohama, Japan</p>
<p><strong>A micromechanics-based phase field approach to fracture</strong> (2019). <em><strong>Y. Liu</strong>, C. Cheng, Y. Shen</em>. Presented at <em>The 2nd International Conference of Mechanics of Advanced Materials and Structures</em>, Nanjing, China</p>
<p><strong>A manifold learning approach for multiscale phase field evolution for fracture</strong> (2019). <em><strong>Y. Liu</strong>, K. Weng, Y. Shen</em>. Presented at <em>The International Conference on Data Driven Computing and Machine Learning in Engineering</em>, Shanghai, China</p>
<p><strong>A homogenization-based phase field approach to fracture</strong> (2019). <em><strong>Y. Liu</strong>, C. Cheng, Y. Shen</em>. Presented at <em>the 15th United States National Congress on Computational Mechanics (USNCCM15)</em>, Austin, Texas</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 Yangyuanchen Liu</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This website is built with <a href="https://github.com/lyyc199586/lyyc199586.github.io">Github Pages</a> and <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>